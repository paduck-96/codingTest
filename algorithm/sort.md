---
---
`알고리즘 사이트 : https://visualgo.net/en`
# 정렬
## JS 내장형 Sort
- 기본적으로는 array.sort( ) 함수로 사용
- 함수에는 a, b 매개변수가 있는데,  
이 둘의 차가 양수일 경우 자리를 바꾸고(정렬)  
음수일 경우 넘어간다.

## 버블 정렬
- 주로 사용되는 정렬은 아님
- `오름차순 정렬의 경우, 큰 수가 계속해서 뒤로 밀린다`
- 가장 큰 값이 맨 뒤로 가게 되고(정렬 완료),  
반복을 할 때마다 하나씩 줄어든 상태로 정렬이 진행된다
### 버블 정렬 - 구현
- 외부 반복문이 돌아가는데 / 변수명 i를 사용해 / 맨 뒤에서부터 앞까지 반복  
`버블 정렬 자체가 마지막에 큰 값이 고정되기 때문에`  
`마지막 값은 제외하면서 돌아야하기 때문`
- 내부 반복문은 변수명 j를 사용해 / 처음부터 i-1까지 반복
- arr[j] 가 arr[j+1] 보다 클 경우 교환
- 하지만, 이럴 경우 **교환할 필요가 없어도** 반복이 진행  
`교환이 발생하지 않았다면 이후에도 추가 교환 불필요`
### 버블 정렬 - 복잡도
- 중첩 루프형태이므로 /  O(n*2)
- 추가 교환 불필요, 데이터가 거의 정렬되었을 경우 /  O(n) 에 가까움
---
## 선택 정렬
- `최소값이 앞으로 오게 되는 정렬`
### 선택 정렬 - 구현
- 남아 있는 배열에서 최소값을 구함
- 반복문을 진행하면서 해당 값을 비교 / 더 작은 수 발견시 스왑
- 외부 반복문은 전체 배열을 탐색하는 반복문 / i라는 변수를 사용해 /해당 인덱스를 최소로 지정
- 내부 반복문은 최소값을 구해서 첫번째 인덱스와 변경하는 반복문 / j라는 변수를 사용해 / i+1 요소부터 비교 시작
### 선택 정렬 - 복잡도
- 중첩 반복문이고, 모든 요소를 탐색하므로 / O(n*2)
- 실제 swap 과정이(메모리 소요) 가 적어질수록 버블보다 효율적
---
## 삽입 정렬
- 한 번에 하나를 맞는 자리에 정렬 시키는 방법
- 배열에 두 번째 요소에서 시작 /  첫 인덱스는 이미 정렬된 것으로 간주
- `데이터 삽입 시 효과적`
### 삽입 정렬 - 구현
- 정렬된 요소와 비교할 외부 반복문
- 내부 반복문은 / 외부 반복문보다 하나 작은 값에서부터 / 음수보다 클 때까지 감소 /  
j 의 값이 / 현재 값보다 클 경우에만 반복(조건 추가)
  - j+1(정렬 중)에 / 내부 반복문 값 삽입
- 이후에 현재 값을 / j+1(정렬 중)에 삽입
### 삽입 정렬 - 복잡도
- 배열의 길이가 늘어날수록 / O(n*2)
- 정렬되어 있는 배열일 경우 / O(n)
---
## 합병 정렬
- 분할, 정복 알고리즘으로라도 볼 수 있음
- 최소한으로 분할한 후 정복하며 정렬
### 합병 정렬 - 구현(내부)
- 두 개의 배열을 기준으로 / 각 배열의 첫 번째 인덱스부터 비교를 시작
- 더 작은 값을 새로 만들 배열에 삽입 / 배열에 끝에 도달할 때까지 반복
  - `각 배열의 정렬 방식은 동일해야함`
- 이후 작은 배열의 반복이 끝났으면 / 나머지 요소 전체 삽입
### 합병 정렬 - 구현(외부)
- 계속 분할을 진행 > Array.slice( )를 활용한 재귀 반복
  - 이후 재귀 합병을 통해 반복
- 배열의 길이가 하나 혹은 적게 될 때까지 반복 / 배열 길이의 반을 인덱스로 사용(slice)
  - 재귀를 통해 구현(외부) 반복
- 이후 합병 정렬 구현(내부) 반환
### 합병 정렬 - 복잡도
- 최악,최선, 평균적으로 / 위의 3 정렬보다 적은 / O(n log n)
- 마찬가지로 배열 하나에서만 정렬 / O(n)